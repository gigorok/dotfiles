#!/usr/bin/env rvm system do ruby
# vim: set ft=ruby:

# require 'byebug'
require 'yaml'
worktree_preferences = YAML.load_file("#{Dir.home}/.config/worktree.yml")
begin
  require 'gitlab'
  Gitlab.configure do |config|
    config.endpoint       = worktree_preferences['gitlab']['endpoint']
    config.private_token  = worktree_preferences['gitlab']['private_token']
  end
rescue LoadError => _e
  puts 'No gitlab gem detected!'
end

def system_cmd(command)
  IO.popen(command)
end

module WorkTree
  class Error < StandardError
  end

  # worktree add feature
  class Add
    def initialize(branch)
      @branch = branch
    end

    def do!
      raise Error, "Folder #{@branch} already exists!" if dir_exists?
      raise Error, 'No master repo found!' unless Dir.exist?("#{master_repo}/.git")
      Dir.chdir('master') do
        if branch_exists?
          link_branch
        else
          git_fetch # fetch before
          git_pull # pull before
          gitlab.in_progress! if defined?(::Gitlab) && File.exist?('../gitlab.yml')
          create
        end
      end
    end

    private

    def gitlab
      WorkTree::Gitlab.new(@branch)
    end

    def git_fetch
      Kernel.system 'git fetch --all'
    end

    def git_pull
      # we are inside master so pull it from upstream master
      Kernel.system 'git pull upstream master'
    end

    def create
      # you can set branch to make worktree from
      # worktree add some-branch upstream/didww
      Kernel.system "git worktree add -b #{@branch} ../#{@branch} #{branch_remote}"
      copy_files
      Dir.chdir("../#{@branch}") do
        create_exrc if branch_remote != 'upstream/master'
        tmux
      end
    end

    # when you are branching from different remote or remote branch
    # then creates .exrc file to make vim work properly with git
    def create_exrc
      File.open('.exrc', 'w') do |file|
        exrc_content = <<-EXRC
let g:pull_remote = '#{branch_remote.split('/')[0]}'
let g:pull_remote_branch = '#{branch_remote.split('/')[1]}'
        EXRC
        file.write(exrc_content)
      end
    end

    def branch_remote
      ARGV[2] || 'upstream/master'
    end

    def link_branch
      puts "Branch #{@branch} already exists."
      print 'Do you want to link it with worktree? [Y/n] '
      answer = STDIN.gets.strip
      if ['Y', 'y', ''].include?(answer)
        Kernel.system "git worktree add ../#{@branch} #{@branch}"
        puts "The branch was linked with directory #{@branch}"
        copy_files
      else
        puts 'Leaving. No changes were made!'
      end
    end

    def dir_exists?
      Dir.exist?("#{Dir.pwd}/#{@branch}")
    end

    def branch_exists?
      system_cmd("git branch --list #{@branch}").read.strip != ''
    end

    def master_repo
      "#{Dir.pwd}/master"
    end

    def tmux
      tmux_session_name = @branch.tr('.', '-')
      Kernel.system "cd ../#{@branch}; tmux new-session -t #{tmux_session_name} -d"
      Kernel.system "cd ../#{@branch}; tmux new-window -n vim"
      Kernel.system 'tmux send-keys "vim" C-m'
      Kernel.system "tmux attach-session -t #{tmux_session_name}"
    end

    def copy_files
      unless File.exist?("../#{@branch}/.gitignore")
        Kernel.system "ln .gitignore ../#{@branch}/"
      end
      if File.exist?('.ruby-version')
        Kernel.system "cp .ruby-version ../#{@branch}/"
      end
      if File.exist?('config/projections.json')
        Kernel.system "ln config/projections.json ../#{@branch}/config/"
      end
      Kernel.system "cp config/*.yml ../#{@branch}/config/"
      if File.exist?('.pg_version')
        Kernel.system "cp .pg_version ../#{@branch}/"
      end
    end
  end

  # worktree remove feature
  class Remove
    def initialize(branch)
      @branch = branch
    end

    def do!
      if dir_exists?
        print "Do you want to remove #{Dir.pwd}/#{@branch} ? [Y/n] "
        answer = STDIN.gets.strip
        if ['Y', 'y', ''].include?(answer)
          Kernel.system "rm -rf #{Dir.pwd}/#{@branch}"
        end
      end
      Dir.chdir('master') do
        Kernel.system 'git worktree prune'
        # if remote branch exists then remove it also
        if system_cmd("git ls-remote --heads $(git config remote.origin.url) #{@branch}").read.strip != ''
          print "Do you want to remove remote branch origin/#{@branch} ? [Y/n] "
          answer = STDIN.gets.strip
          if ['Y', 'y', ''].include?(answer)
            unless Kernel.system("git push -d origin #{@branch}")
              raise Error, 'Something get wrong while removing remote branch!'
            end
          end
        else
          puts "No remote branch origin/#{@branch} detected!"
        end
        # remove local branch
        Kernel.system "git branch -d #{@branch}"
      end
    end

    def dir_exists?
      Dir.exist?("#{Dir.pwd}/#{@branch}")
    end
  end

  # worktree gitlab feature
  class Gitlab
    def initialize(branch)
      @branch = branch
    end

    def in_progress!
      label = gitlab_preferences['in_progress_label'] || 'In Progress'
      apply_label(label, ['Resolved'])
    end

    def resolve!
      label = gitlab_preferences['resolve_label'] || 'Resolved'
      apply_label(label, ['In Progress'])
    end

    def apply_label(label, to_remove=[])
      print "Do you want to apply #{label} label to the issue ##{gitlab_issue_id}? [Y/n] "
      answer = STDIN.gets.strip
      if ['Y', 'y', ''].include?(answer)
        issue = ::Gitlab.issue(gitlab_project_id, gitlab_issue_id)
        labels = issue.labels
        if labels.include?(label)
          puts "The label #{label} already applied!"
        else
          issue_options = {
            labels: (labels + [label] - to_remove).join(',')
          }
          ::Gitlab.edit_issue(gitlab_project_id, gitlab_issue_id, issue_options)
        end
      end
    end

    def gitlab_preferences
      YAML.load_file('../gitlab.yml')
    end

    # example 7944-feature-name
    def gitlab_issue_id
      @branch.split('/').last.split('-')[0]
    end

    def gitlab_project_id
      gitlab_preferences['project_id']
    end
  end
end

case ARGV[0].to_s.strip
when 'add', 'new'
  WorkTree::Add.new(ARGV[1]).do!
when ''
  puts 'required args'
when 'remove', 'delete'
  WorkTree::Remove.new(ARGV[1]).do!
when 'resolve_issue'
  # Dir.chdir('master') do
    if defined?(::Gitlab) && File.exist?('../gitlab.yml')
      WorkTree::Gitlab.new(ARGV[1]).resolve!
    else
      'gitlab gem is not installed!'
    end
  # end
else
  puts 'unknown command'
end
